version: 0.2
phases:
  pre_build:
    commands:
      - echo "=== Determining Blue-Green Deployment Target ==="
      - echo "Blue TG ARN $BLUE_TG_ARN"
      - echo "Green TG ARN $GREEN_TG_ARN"
      - echo "Listener ARN $LISTENER_ARN"
      - |
        # Query default rule weights
        WEIGHTS=$(aws elbv2 describe-rules --listener-arn $LISTENER_ARN --region $AWS_REGION --query 'Rules[?IsDefault==`true`].Actions[0].ForwardConfig.TargetGroups[*].[TargetGroupArn,Weight]' --output text)
        echo "Target group weights:"
        echo "$WEIGHTS"
        
        # Parse weights for blue and green
        BLUE_WEIGHT=$(echo "$WEIGHTS" | grep "$BLUE_TG_ARN" | awk '{print $2}')
        GREEN_WEIGHT=$(echo "$WEIGHTS" | grep "$GREEN_TG_ARN" | awk '{print $2}')
        
        echo "Blue weight: $BLUE_WEIGHT"
        echo "Green weight: $GREEN_WEIGHT"
        
        # Handle empty values
        if [ -z "$BLUE_WEIGHT" ]; then BLUE_WEIGHT=0; fi
        if [ -z "$GREEN_WEIGHT" ]; then GREEN_WEIGHT=0; fi
        
        # Determine deployment target (deploy to the one with weight 0)
        if [ "$BLUE_WEIGHT" -eq 0 ] && [ "$GREEN_WEIGHT" -gt 0 ]; then
          export DEPLOYMENT_TARGET="blue"
          export EFS_MOUNT="/mnt/efs_blue"
          export TASK_FAMILY="$BLUE_TASK_FAMILY"
          export SERVICE_NAME="$BLUE_SERVICE_NAME"
          echo "Blue has 0 weight, deploying to BLUE environment"
        elif [ "$GREEN_WEIGHT" -eq 0 ] && [ "$BLUE_WEIGHT" -gt 0 ]; then
          export DEPLOYMENT_TARGET="green"
          export EFS_MOUNT="/mnt/efs_green"
          export TASK_FAMILY="$GREEN_TASK_FAMILY"
          export SERVICE_NAME="$GREEN_SERVICE_NAME"
          echo "Green has 0 weight, deploying to GREEN environment"
        else
          echo "ERROR: Both environments have non-zero weights or both are zero!"
          echo "Blue weight: $BLUE_WEIGHT, Green weight: $GREEN_WEIGHT"
          echo "Cannot determine deployment target. Please ensure one environment has 0 weight."
          exit 1
        fi
        
        # Read VERSION_TAG from previous stage
        echo "=== Reading VERSION_TAG from previous stage ==="
        VERSION_TAG=$(cat version_tag.txt | tr -d '\n\r ')
        echo "Using image tag: $VERSION_TAG"
  build:
    commands:
      - |
        echo "=== Syncing wp-content to EFS ==="
        echo "Creating EFS directory structure if needed"
        mkdir -p $EFS_MOUNT/wp-content
        echo "Clearing target EFS directory $EFS_MOUNT/wp-content"
        rm -rf $EFS_MOUNT/wp-content/*
        echo "Copying wp-content from source to EFS"
        test -d ./wp-content && cp -r ./wp-content/* $EFS_MOUNT/wp-content/ || echo "No wp-content directory found in source"
        echo "EFS sync complete"
        ls -la $EFS_MOUNT/wp-content/ || echo "Unable to list directory contents"
        
        # Update ECS Task Definition
        echo "=== Updating ECS Task Definition Image ==="
        echo "Updating task family: $TASK_FAMILY"
        TASK_DEF=$(aws ecs describe-task-definition --task-definition $TASK_FAMILY --region $AWS_REGION)
        NEW_TASK_DEF=$(echo $TASK_DEF | jq --arg IMAGE "$ECR_REPOSITORY_URI:$VERSION_TAG" '.taskDefinition | .containerDefinitions[0].image = $IMAGE | del(.taskDefinitionArn, .revision, .status, .requiresAttributes, .compatibilities, .registeredAt, .registeredBy)')
        echo "Registering new task definition..."
        NEW_TASK_DEF_ARN=$(aws ecs register-task-definition --cli-input-json "$NEW_TASK_DEF" --region $AWS_REGION --query 'taskDefinition.taskDefinitionArn' --output text)
        echo "New task definition ARN: $NEW_TASK_DEF_ARN"
        
        # Update ECS Service
        echo "=== Updating ECS Service ==="
        echo "Updating service $SERVICE_NAME to use new task definition"
        aws ecs update-service --cluster $ECS_CLUSTER_NAME --service $SERVICE_NAME --task-definition $NEW_TASK_DEF_ARN --region $AWS_REGION
        echo "Service updated successfully"
        echo "=== Deployment complete ==="
